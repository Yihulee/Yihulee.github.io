#+TITLE:       关于编译器
#+AUTHOR:      Yihulee
#+EMAIL:       lishuhuakai@gmail.com
#+DATE:        2016-07-12 周二
#+URI:         /blog/%y/%m/%d/关于编译器
#+KEYWORDS:    compiler
#+TAGS:        compiler
#+LANGUAGE:    en
#+OPTIONS:     H:3 num:nil toc:nil \n:nil ::t |:t ^:nil -:nil f:t *:t <:t
#+DESCRIPTION: 当然，我在扯淡！

好吧，我其实真的是挺兴奋的，真的，今年过来的时候，我就定下了今年上半年的一个目标，那就是玩玩编译器之类的东西，到了今天，这个任务不能说是失败吧，毕竟我也写了几个解释器，有 *scheme语言* , *let语言*, *JavaScript及Html*,别激动，实现的只是它们多如牛毛的特性中的一些比较重要的特性的一个子集而已。 那种翻译成某种结构体系下的汇编代码的编译器也写了一个，虽然说实现了简单加减乘除运算的编译器只是一个玩具一样的东西。但你还别说，它还真是一个编译器。

解释器严格的来说只能是半个编译器吧，它和编译器一样，同样有 *词法分析* , *语法分析*, *语义分析*,这样几个阶段，要是你的解释器强大一点的话，可以顺带做一下类型检查，你要愿意的话，也可以做一下代码优化什么的。编译器和解释器唯一个不同是，编译器并不执行代码，它只是翻译代码，我们管这玩意叫做翻译器更为恰当，解释器不一样，它还顺带做了 *CUP* 应该干的事情，那就是解释执行。

在没做过这些东西之前，我一直以为，这些玩意挺难的，不过，当自己真正上手了之后，我突然发现，一切并没有想象中的那么难，特别是现代，供你选择的工具实在太多，前端有一大波工具供你词法分析和语法分析。 *C* 和 *C++* 端有 *flex* 和 *bison*, *Java* 端有 *JLex*, *CUP* 以及 *Antlr* , *Python* 端有 *Ply* 。当然，最爽的还是 *Ply*,写起来最简单啦！

后端的话，有 *JVM* 和 *LLVM* ，你在实际生活中要做一个 *DSL* 的话，写一写规则就可以快速生成需要的东西了，当然，学习的阶段还是有必要深入一点，自己来写一下词法分析器和语法分析器，语法分析器的LR(1)写起来难度挺大的。是在不行，自己手写语法分析，自底向上来分析。

好吧，确实挺爽的，不过，这段时间写完 *stanford* 的 *cs143* 的 *cool* 编译器之后，我上学年的目标应该就达成了，下学期的话，真的研二了，该干点别的事情了。至少在研究生读完之前，我很难再抽出时间在来写什么编译器了。

这个 *cool* 编译器最多不会超过 *20* 天就能写完，虽然有些长，但是应该是值得的。

加油！

