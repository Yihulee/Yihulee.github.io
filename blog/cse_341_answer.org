#+TITLE:       Programming language 解题报告
#+AUTHOR:      Yihulee
#+EMAIL:       Yihulee@gmail.com
#+DATE:        2016-02-24 周三
#+URI:         /blog/%y/%m/%d/programming-language-解题报告
#+KEYWORDS:    Programming Language
#+TAGS:        wiki
#+LANGUAGE:    en
#+OPTIONS:     H:3 num:t toc:t \n:nil ::t |:t ^:nil -:nil f:t *:t <:t
#+DESCRIPTION: 解题报告

* homework1
** is_older
#+BEGIN_SRC sml
fun is_older (date1 : (int * int * int), date2 : (int * int * int)) =
  (*这个函数的要求是判断date1是否比date2更早，其实非常好判断，直接按照年月日判断即可*)
  if (#1 date1) <> (#1 date2) (* 年的值不同 *)
  then (#1 date1) < (#1 date2)
  else if (#2 date1) <> (#2 date2) (* 月的值不同 *)
  then (#2 date1) < (#2 date2)
  else if (#3 date1) <> (#3 date2) (* 天数不同 *)
  then (#3 date1) < (#3 date2)
  else false (* 到这里表示两个日期相同,返回false *)
#+END_SRC
** number_in_month
#+BEGIN_SRC sml
fun number_in_month (dl : (int * int * int) list, month : int) =
  (* 参数是一个 list of dates 和一个 month,要返回的结果是在指定的这个月里，这个dates中月份等于该month的一共有多少个 *)
  if null dl
  then 0
  else if (#2 (hd dl)) = month
  then 1 + number_in_month(tl dl, month)
  else number_in_month(tl dl, month)
#+END_SRC

** number_in_months
#+BEGIN_SRC sml
fun number_in_months(dl : (int * int * int) list, ml : int list) =
  if null ml
  then []
  else number_in_month(dl, hd ml)::number_in_months(dl, tl ml)
#+END_SRC

** dates_in_month
#+BEGIN_SRC sml
fun dates_in_month(dl : (int * int * int) list, m : int) =
  if null dl
  then []
  else if (#2 (hd dl)) = m
  then (hd dl)::dates_in_month(tl dl, m)
  else dates_in_month(tl dl, m)
#+END_SRC

** dates_in_months
#+BEGIN_SRC sml
fun dates_in_months(dl : (int * int * int) list, ml : int list) =
  if null ml
  then []
  else [dates_in_month(dl, hd ml)] @ dates_in_months(dl, tl ml)

#+END_SRC

** get_nth
#+BEGIN_SRC sml
fun get_nth (sl : string list , nth : int) =
  (* 题目里的说明是不用担心sl太短，这样的话，函数就可以变得很简洁了*)
  if nth = 1
  then hd sl
  else get_nth(tl sl, nth - 1)
#+END_SRC

** date_to_string
#+BEGIN_SRC sml
fun date_to_string (date : (int * int * int)) =
  let val ml = ["January", "February", "March",
	  "April", "May", "June", "July",
	  "August", "September", "October",
	  "November", "December"]
  in
     get_nth(ml, (#2 date)) ^ " " ^Int.toString((#3 date)) ^ ", " ^ Int.toString((#1 date))
  end
#+END_SRC

** number_before_reaching_sum
#+BEGIN_SRC sml
fun number_before_reaching_sum (sum : int, il : int list) =
  (* 这玩意挺爽的一点是，里面可以做辅助函数 *)
  let
      fun helper (il : int list, sum_of_n_items : int, n_item : int) = (* sum_of_n_items是前面的n项的和，n_item是第n项*)
	if sum_of_n_items >= sum
	then n_item
	else helper(tl il, sum_of_n_items + hd il, n_item + 1)
  in
      helper(il, 0, 0)
  end
#+END_SRC

** what_month
#+BEGIN_SRC sml
fun what_month (day : int) =
  (* 这是一个简化版的程序，忽略了闰年 *)
  let
      val day_of_each_month = [31, 28, 31, 30,
			       31, 30, 31, 31,
			       30, 31, 30, 31] (* 每个月的天数 *)
      fun count_days (rest_days : int, day_of_each_month : int list, nth : int) =
	if rest_days <=  hd day_of_each_month
	then nth
	else count_days(rest_days - hd day_of_each_month, tl day_of_each_month, nth + 1)
  in
      count_days(day, day_of_each_month, 1)
  end

#+END_SRC

** month_range
#+BEGIN_SRC sml
fun month_range (day1 : int, day2 : int) =
  if day1 > day2
  then []
  else if day1 = day2
  then [what_month(day2)]
  else what_month(day1)::month_range(day1 + 1, day2)
#+END_SRC

** oldest
#+BEGIN_SRC sml
fun oldest (dl : (int * int * int) list) =
  if null dl
  then NONE
  else let
      fun oldest_date(dl : (int * int * int) list) =
	if null (tl dl)
	then hd dl
	else let val dl_ans = oldest_date(tl dl)
	     in
		 if is_older(dl_ans, hd dl)
		 then hd dl
		 else dl_ans
	     end
  in
      SOME(oldest_date(dl))
  end

#+END_SRC

** number_in_months_challenge
#+BEGIN_SRC sml
fun number_in_months_challenge (dl : (int * int * int) list, ml : int list) =
  (* 我们要做的是，去除重复的月份即可,使用local function *)
  let
      fun reverse_list(il : int list) =
      (* 这个函数用于反转list *)
	let
	    fun iter (remained_list : int list, result : int list) =
	      if null remained_list
	      then result
	      else iter(tl remained_list, hd remained_list :: result)
	in
	    iter(il, [])
	end
	    
      fun filter_dup (il : int list, result : int list) =
	(* 关键的问题在于如何去除重复 *)
	if null il
	then result
	else if
	    let
		fun in_the_list (n : int , il : int list) = (* 这个函数主要用来判断n是否在il这个int list之中*)
		  if null il
		  then false
		  else if n = hd il
		  then true
		  else in_the_list(n, tl il) (* 这个函数的定义倒是没有什么错误 *)
	    in
		in_the_list(hd il, result) (* 判断 hd il 是否在result之中*)
	    end
	then filter_dup(tl il, result) (* 在result之中，则继续迭代*)
	else filter_dup(tl il, hd il::result) (* 不在result之中，则加入result*)
  in
      number_in_months(dl, reverse_list(filter_dup(ml, [])))
  end
#+END_SRC
** reasonable_date
#+BEGIN_SRC sml
(* 最后一个函数了 *)
fun reasonable_date (date : (int * int * int)) =
  if (#1 date) <= 0
  then false
  else if (# 2 date) > 12 orelse (#2 date) < 1
  then false
  else
      let
	  fun is_leap_year(year : int) =
	    (* 判断某年是否为闰年 *)
	    if year mod 400 = 0 orelse (year mod 4 = 0 andalso year mod 100 <> 0)
	    then true
	    else false

	  fun get_nth(il : int list, n : int) = (* 取list表单的第n项 *)
	     if n = 1
	     then hd il
	     else get_nth(tl il, n - 1)

	  val day_of_each_month_in_leap_year = [31, 29, 31, 30,
						31, 30, 31, 31,
						30, 31, 30, 31]

	  val day_of_each_month_in_ord_year = [31, 28, 31, 30,
						31, 30, 31, 31,
						30, 31, 30, 31]
      in
	  let
	      fun is_day_right(d : int, m : int, day_of_each_month : int list) =
		if d > 0 andalso d <= get_nth(day_of_each_month, m)
		then true
		else false
	  in
	      if is_leap_year((#1 date))
	      then is_day_right((#3 date), (#2 date), day_of_each_month_in_leap_year) (* 如果是闰年 *)
	      else is_day_right((#3 date), (#2 date), day_of_each_month_in_ord_year) (* 如果不是闰年 *)
	  end
	      
      end

#+END_SRC
* homework2
** all_except_iotion
#+BEGIN_SRC sml
fun same_string(s1 : string, s2 : string) =
    s1 = s2

(* 不允许使用函数null, hd, tl, isSome, valOf, or # *)
fun all_except_option (str, strl) =
  (* 我来分析一下匹配的结果，首先，如果strl为空，自然返回NONE
     然后，如果strl的首元素和str匹配，返回SOME，否则的话，继续递归 *)
  (* 这里有一个假设，那就是str至多在strl中出现一次 *)
  case strl of
      [] => NONE
    | x::xs' => if same_string(str, x)
		then SOME(xs') (* 去除了str后形成的新的SOME *)
		else
		    let val re = all_except_option(str, xs')
		    in
			case re of
			    NONE => NONE
			 | SOME px => SOME(x::px)
		    end

#+END_SRC

** get_substitutions1
#+BEGIN_SRC sml
fun get_substitutions1 (sll, s) =
(* 这个函数显然要用到前面定义的辅助函数 *)
  case sll of
      [] => []
    | x::xs' => let val re = all_except_option(s, x)
		in case re of
		       NONE => get_substitutions1(xs', s)
		     | SOME v => v @ get_substitutions1(xs', s)
		end
#+END_SRC

** get_substitutions2
#+BEGIN_SRC sml
fun get_substitutions2 (sll, s) =
(* 尾递归版本的替换 *)
  let fun sub(sll, acc) =
	case sll of
	    [] => acc
	  | x::xs' => let val re = all_except_option(s, x) (* 得到这个list的结果 *)
		      in case re of
			     NONE => sub(xs', acc) (* 继续往后面递归 *)
			   | SOME v => sub(xs', v @ acc) (* 累积一下，继续递归 *)
		      end
  in
      sub(sll, [])
  end
#+END_SRC
** similar_names
#+BEGIN_SRC sml
fun similar_names (sll, full_name) =
(* 其实也是很简单的一道题目 *)
  let
      val {first = x, middle = y, last = z} = full_name
      val ans = [full_name] (* 事先将full_name装入 *)
  in
      let
	  val temp =  get_substitutions2(sll, x) (* 这样可以得到一个替换的结果,用first name x 去替换 *)
	  fun sub (sl, ans) =
	    case sl of
		[] => ans
	      | h::t  =>  sub(t, {first = h, middle = y, last = z} :: ans)
									
      in
	  sub(temp, ans) (* 替换 *)
      end
  end
#+END_SRC
** card_color
#+BEGIN_SRC sml
datatype suit = Clubs | Diamonds | Hearts | Spades
datatype rank = Jack | Queen | King | Ace | Num of int 
type card = suit * rank

datatype color = Red | Black
datatype move = Discard of card | Draw 

exception IllegalMove

(* put your solutions for problem 2 here *)
fun card_color (c) =
  case c of
      (s, k) => k

#+END_SRC

** card_value
#+BEGIN_SRC sml
fun card_value (c, k) =
  case k of
      Ace => 11
    | Num i => i
    | _ => 10
#+END_SRC
** remove_card
#+BEGIN_SRC sml
fun remove_card	(cs, c, exn) =
  case cs of
      ac :: rc => if ac = c
		  then rc
		  else ac :: remove_card(rc, c, exn)
    | [] => raise exn
#+END_SRC
** all_same_color
#+BEGIN_SRC sml
fun all_same_color (cs) =
  case cs of
      (c1, v1) :: (c2, v2) :: rc => if c1 = c2
				    then all_same_color((c2, v2) :: rc)
				    else false
    | _  => true 
#+END_SRC
** sum_cards
#+BEGIN_SRC sml
fun sum_cards (cs) =
  (* 需要使用到尾递归 *)
  let
      fun helper_sum_cards(cards, acc) =
	case cards of
	    c :: rc => helper_sum_cards(rc, card_value(c) + acc)
	  | [] =>  acc
  in
      helper_sum_cards(cs, 0)
  end
#+END_SRC
** score
#+BEGIN_SRC sml
fun score (cs, goal) =
  (* 计算成绩 *)
  let val sum = sum_cards(cs)
  in
      let
	  val  reliminary_score =      
	      if sum > goal
	      then 3 * (sum - goal)
	      else goal - sum
      in
	  if all_same_color(cs) (* 如果牌是相同的颜色，那么成绩就是preliminary score除2 *)
	  then reliminary_score
	  else reliminary_score div 2
      end
  end
#+END_SRC

** officiate
#+BEGIN_SRC sml
fun officiate (card_list, move_list, goal) =
  let
      fun helper_officiate (card_list, herd_list, move_list, goal) =
	(* card_list是牌的列表，herd_list是现在手里有的牌的列表，而move_list表示每一步应该怎样走 *)
	case move_list of
	    [] => score(herd_list, goal) (* 移动列表中已经没有东西了，立即返回score *)
	  | Draw :: rest_moves => (* 这里的要求是，抓取一张牌 *) 
	    (case card_list of 
		 card :: rest_cards =>
		 let
		     val new_herd_list = card :: herd_list
		 in
		     if sum_cards(new_herd_list) > goal (* 抓牌后是的新的herd_list的分数sum超过了goal *)
		     then score(new_herd_list, goal)
		     else  helper_officiate(rest_cards, card :: herd_list, rest_moves, goal) 
		 end
	       | [] => score(herd_list, goal) (* 已经没有牌了，游戏结束，所以返回score *)
	    )
	 |  Discard card :: rest_moves =>  helper_officiate(card_list, remove_card(herd_list, card, IllegalMove), rest_moves, goal)
  in
      helper_officiate(card_list, [], move_list, goal)
  end
#+END_SRC
* homework3
  这次的东西确实有一点难度!
#+BEGIN_SRC sml
(* Dan Grossman, CSE341 Spring 2013, HW3 Provided Code *)
exception NoAnswer

datatype pattern = Wildcard
		 | Variable of string
		 | UnitP
		 | ConstP of int
		 | TupleP of pattern list
		 | ConstructorP of string * pattern

datatype valu = Const of int
	      | Unit
	      | Tuple of valu list
	      | Constructor of string * valu

fun g f1 f2 p =
    let 
	val r = g f1 f2 (* partial function *)
    in
	case p of (* p的类型是pattern *)
	    Wildcard          => f1 ()
	  | Variable x        => f2 x
	  | TupleP ps         => List.foldl (fn (p,i) => (r p) + i) 0 ps (* ps是一个list，r是一个函数，使用一个参数，返回int *)
	  | ConstructorP(_,p) => r p (* 只是要干什么呀 *)
	  | _                 => 0
    end

(* 题目要求是使用g来count_wildcards *)
#+END_SRC

** count_wildcards
					   
#+BEGIN_SRC sml
fun count_wildcards p =
  case p of
      ConstructorP (_, np) => count_wildcards np (* np也是一个pattern *)
    | Wildcard => 1
    | TupleP plist => (case plist of
			   x::(y::xs') => count_wildcards x + count_wildcards (TupleP (y::xs'))
			 | x::[] => count_wildcards x)
    | _ => 0
(*
    | ConstP _ => 0
    | UnitP => 0
    | Variable _ => 0 
*)

#+END_SRC

** count_wildcards_e
					   
#+BEGIN_SRC sml
fun count_wildcards_e p =
  g (fn x => 1) (fn x => 0) p
#+END_SRC

** count_wild_and_variable_lengths
					   
#+BEGIN_SRC sml
fun count_wild_and_variable_lengths p =
  g (fn x => 1) (fn x => String.size x) p

#+END_SRC

** count_some_var
					   
#+BEGIN_SRC sml
fun count_some_var s p =
  g (fn x => 0) (fn x => if x = s then 1 else 0) p

#+END_SRC

** check_pat
					   
#+BEGIN_SRC sml
fun check_pat p =
  let
      fun collect_string p =
	case p of
	    Variable s => [s]
	  | TupleP ps  => List.foldl (fn (p, i) => i @ (collect_string p)) [] ps
	  | _ => []
      fun is_dup sl =
	case sl of
	    [] => false
	  | x::xs' => (List.exists (fn s => if x = s then true else false) xs') orelse is_dup xs' 
  in
     is_dup((collect_string p))
  end

#+END_SRC

** only_capitals
					   
#+BEGIN_SRC sml
fun only_capitals (sl) =
  List.filter (fn x => Char.isUpper (String.sub(x, 0)))  sl
   #+END_SRC

** longest_string1
					   
#+BEGIN_SRC sml
(* foldl函数从左边干到右边，foldr函数从右边干到左边 *)
fun longest_string1 sl =
  foldl (fn (x, y) => if String.size x  > String.size y then x else y) "" sl   
 #+END_SRC

** longest_string2
					   
#+BEGIN_SRC sml
fun longest_string2 sl =
  foldl (fn (x, y) => if String.size x >= String.size y then x  else y) "" sl
 #+END_SRC

** longest_string3
					   
#+BEGIN_SRC sml	
 val longest_string3 = foldl (fn (x, y) => if String.size x  > String.size y then x else y) ""
 #+END_SRC

** longest_string4
					   
#+BEGIN_SRC sml
 val longest_string4 = foldl (fn (x, y) => if String.size x >= String.size y then x else y) ""
#+END_SRC

** longest_string_helper
					   
#+BEGIN_SRC sml			     
 fun longest_string_helper f sl = f sl
#+END_SRC

** longest_capitalized
					   
#+BEGIN_SRC sml
 val longest_capitalized = (longest_string1 o only_capitals)
 #+END_SRC

** rev_string					   
#+BEGIN_SRC sml
 val rev_string  = implode o rev o explode
#+END_SRC

** first_answer					   
#+BEGIN_SRC sml
 fun first_answer f l =
   (* f作用在list之上，然后直到list返回一个SOME v*)
   case l of
       [] => raise NoAnswer
     | h::t => case f(h) of
		   SOME v => v
		 | _ => first_answer f t
#+END_SRC

** all_answers 					   
#+BEGIN_SRC sml
 (* list option和option list很值得注意 *)
 (* ('a -> 'b list option) -> 'a list -> 'b list option *)
 fun all_answers f l =
   (* 函数存在一些问题啊!l中的某个元素被f作用之后产生NONE，整个结果就是NONE，感觉不是很好递归的样子 *)
   case l of
       [] => SOME [] (*返回一个list option *)
     | h::t => case f(h) of
		   NONE => NONE
		 | SOME r =>
		   let
		      val re = (all_answers f t) (* 需要说明一下，re是一个list option,也就是说，如果re为SOME v，那么v是一个list*)
		   in
		       case re of
			   NONE => NONE
			 | SOME v => SOME(r @ v) 
		   end
#+END_SRC
** match


#+BEGIN_SRC sml
fun match v_p =
   case v_p of
       (_ ,Wildcard) => SOME [] (* Wildcard 匹配一切 *)
     | (v, Variable s) => SOME [(s, v)] (*Variable s匹配任何的valu v*)
     | (Unit, UnitP) => SOME []
     | (Const v1, ConstP v2) => if v1 = v2 then SOME [] else NONE
     | ((Constructor (vs, vv)), (ConstructorP (ps, pp))) => if vs <> ps then NONE else match (vv, pp)
     | (Tuple v, TupleP p) => (all_answers match (ListPair.zip (v, p))) 
     | _ => NONE  (* 其余的都不匹配 *)	
#+END_SRC

** first_match 					   
#+BEGIN_SRC sml
 fun first_match v pl =
   SOME(first_answer (fn x => match (v, x)) pl) handle NoAnswer => NONE
#+END_SRC


* homework4
#+BEGIN_SRC scheme

#lang racket

(provide (all-defined-out)) ;; so we can put tests in a second file

;; put your code below

(define (sequence low high stride)
  (if (> low high)
      null
      (cons low (sequence (+ low stride) high stride))))

(define (string-append-map xs suffix)
  (map (lambda (x) (string-append x suffix)) xs))

(define (list-nth-mod xs n)
  (let ([i (remainder n (length xs))])
    (cond [(< n 0) (error "list-nth-mod: negative number")]
          [(null? xs) (error "list-nth-mod: empty list")]
          [else (begin (car (list-tail xs i)))])))

(define ones (lambda () (cons 1 ones)))
(define nat (letrec ([f (lambda (x) (cons x (lambda () (f (+ x 1)))))])
              (lambda () (f 1))))

(define (stream-for-n-steps s n)
  (if (= n 0)
      null
      (cons (car (s)) (stream-for-n-steps (cdr (s))(- n 1)))))

(define funny-number-stream (letrec ([f (lambda (x)
                                          (if (= (remainder x 5) 0)
                                              (cons (- 0 x)
                                                    (lambda () (f (+ x 1))))
                                              (cons x
                                                    (lambda () (f (+ x 1))))))])
                              (lambda () (f 1))))

(define dan-then-dog (letrec ([f (lambda (x)
                                 (if (= (remainder x 2) 0)
                                     (cons "dan.jpg"
                                           (lambda () (f (+ x 1))))
                                     (cons "dog.jpg"
                                           (lambda () (f (+ x 1))))))])
                       (lambda () (f 0))))
(define (stream-add-zero s)
      (lambda () (cons (cons 0 (car (s))) (stream-add-zero (cdr (s))))))

;; 有了前面的玩意，后面就变得非常简单了
(define (cycle-lists xs ys)
  (letrec ([xl (length xs)] ;得到两个序列的长度
           [yl (length ys)]
           [f (lambda (ax ay) ;; 我们至少需要两个累积量，非常有趣的东西
                (cons (cons (list-nth-mod xs ax) (list-nth-mod ys ay))
                      (lambda () (f (remainder (+ 1 ax) xl) (remainder (+ 1 ay) yl)))))])
    (lambda () (f 0 0))))

(define (vector-assoc v vev)
  (letrec ([len (vector-length vev)]
           [f (lambda (a)
                (if (= (- 1 len) a)
                    #f
                    (letrec ([vv (vector-ref vev a)])
                      (if (and (pair? vv) (equal? (car vv) v))
                              vv
                              (f (+ a 1))))))])
    (f 0)))


(define (cached-assoc xs n)
  (letrec
      ([cached-vector (make-vector n #f)]
       [index 0]
       [f (lambda (av ac) ;; 寻找某一个value,在vector之中
            (cond
              [(= ac n) #f]
              [(letrec ([element-in-vector (vector-ref cached-vector ac)])
                 (and (pair? element-in-vector) (= (car element-in-vector) av) element-in-vector))]
              [else (f av (+ ac 1))]))])
  (lambda (v)
    (letrec ([value-in-vector (f v 0)])
      (cond [(not value-in-vector)
             (letrec ([value-in-list (assoc v xs)])
               (begin (vector-set! cached-vector index value-in-list)
               (set! index (remainder (+ 1 index) n)) value-in-list))] ;; 没有在vector中找到这个值
            [else value-in-vector])))))
;; 定义一个宏 macro
(define-syntax  while-less
  (syntax-rules (do)
                [(while-less e1 do e2)
                 (letrec ([v1 e1]
                       [loop (lambda ()
                                 (if (> e2 (- v1 1))
                                     #t
                                     (loop)))])
                   (loop))]))

            

#+END_SRC
* homework5
#+BEGIN_SRC scheme
;; Programming Languages, Homework 5

#lang racket
(provide (all-defined-out)) ;; so we can put tests in a second file

;; definition of structures for MUPL programs - Do NOT change
(struct var  (string) #:transparent)  ;; a variable, e.g., (var "foo")
(struct int  (num)    #:transparent)  ;; a constant number, e.g., (int 17)
(struct add  (e1 e2)  #:transparent)  ;; add two expressions
(struct ifgreater (e1 e2 e3 e4)    #:transparent) ;; if e1 > e2 then e3 else e4
(struct fun  (nameopt formal body) #:transparent) ;; a recursive(?) 1-argument function
(struct call (funexp actual)       #:transparent) ;; function call
(struct mlet (var e body) #:transparent) ;; a local binding (let var = e in body) 
(struct apair (e1 e2)     #:transparent) ;; make a new pair
(struct fst  (e)    #:transparent) ;; get first part of a pair
(struct snd  (e)    #:transparent) ;; get second part of a pair
(struct aunit ()    #:transparent) ;; unit value -- good for ending a list
(struct isaunit (e) #:transparent) ;; evaluate to 1 if e is unit else 0

;; a closure is not in "source" programs; it is what functions evaluate to
(struct closure (env fun) #:transparent) 

;; Problem 1

;; CHANGE (put your solutions here)
;; 这种题目果然只是用来热身的呀！
(define (racketlist->mupllist rl)
  (if (null? rl) (aunit)
      (apair (car rl) (racketlist->mupllist (cdr rl)))))

(define (mupllist->racketlist ml)
  (if (aunit? ml) null
      (cons (apair-e1 ml) (mupllist->racketlist (apair-e2 ml)))))
;; Problem 2

;; Implementing the MUPL Language

;; lookup a variable in an environment
;; Do NOT change this function
(define (envlookup env str) ;; 在环境env中寻找某个变量
  (cond [(null? env) (error "unbound variable during evaluation" str)]
        [(equal? (car (car env)) str) (cdr (car env))] ;; 如果值相同，就返回env里面的东西
        [#t (envlookup (cdr env) str)]))

;; Do NOT change the two cases given to you.  
;; DO add more cases for other kinds of MUPL expressions.
;; We will test eval-under-env by calling it directly even though
;; "in real life" it would be a helper function of eval-exp.
(define (eval-under-env e env)
  (cond [(var? e) ;; 如果e是变量
         (envlookup env (var-string e))] ;; 在env中寻找对应的值
        [(add? e) ;; 如果e是加法表达式
         (let ([v1 (eval-under-env (add-e1 e) env)]
               [v2 (eval-under-env (add-e2 e) env)])
           (if (and (int? v1)
                    (int? v2))
               (int (+ (int-num v1) 
                       (int-num v2)))
               (begin (print v1) (print v2)(
               (error "MUPL addition applied to non-number")))))]
        ;; CHANGE add more cases here
        [(fst? e) ;; 这里的要求是e的计算结果是apair
         (let ([v (eval-under-env (fst-e e) env)])
           (if (apair? v)
               (apair-e1 v)
               (error "e is not apair")))]
        [(snd? e) ;; 计算snd
         (let ([v (eval-under-env (snd-e e) env)])
           (if (apair? v)
               (apair-e2 v)
               (error "e is not apair")))]
        [(ifgreater? e) ;; 现在要解释ifgreater表达式了
         (let ([v1 (eval-under-env (ifgreater-e1 e) env)]
               [v2 (eval-under-env (ifgreater-e2 e) env)])
           (if (and (int? v1) (int? v2))
               (if (> (int-num v1) (int-num v2))
                   (eval-under-env (ifgreater-e3 e) env)
                   (eval-under-env (ifgreater-e4 e) env))
               (error "ifgreater expression needs two number")))]

        [(int? e) ;; 现在要处理整数
         (let ([v (int-num e)])
           (if (number? v)
               e
               (error "int expression encounter a thing that is not a number!")))]

        [(apair? e) ;; 处理apair表达式
         (let ([v1 (eval-under-env (apair-e1 e) env)]
               [v2 (eval-under-env (apair-e2 e) env)])
           (apair v1 v2))]

        [(fun? e) ;; 现在处理函数，要求可以实现递归哦，是在是太他妈神奇了!
         (let ([fun-name (fun-nameopt e)])
           (if fun-name
               (closure (append (list (cons fun-name e)) env) e)
               (closure env e)))]

        [(mlet? e) ;; 处理mlet表达式
         (letrec ([s (mlet-var e)] ;; 获得变量名
                  [v (eval-under-env (mlet-e e) env)]) ;; 获得值
           (eval-under-env (mlet-body e) (append (list (cons s v)) env)))]

        [(call? e) ;; 这个东西是最重要的啦，我要实现闭包啦。
         (letrec ([v1 (eval-under-env (call-funexp e) env)]
                  [v2 (eval-under-env (call-actual e) env)])
           (if (closure? v1) ;; 要求v1是一个闭包
               (letrec ([fn (closure-fun v1)] ;; 函数本体
                        [fe (closure-env v1)]) ;; 原来的环境
                 (eval-under-env (fun-body fn)
                                 (append (list (cons (fun-formal fn) v2))
                                         fe)))
               (if (fun? v1)
                   (eval-under-env (call v1 v2) env)
                   (error "She is not a closure!"))))]
        [(isaunit? e) ;; 现在开始处理isaunit表达式
         (if (aunit? (eval-under-env (isaunit-e e) env)) (int 1) (int 0))]
        [(aunit? e) e]
        
        [#t (error (format "bad MUPL expression: ~v" e))]))

;; Do NOT change
(define (eval-exp e)
  (eval-under-env e null))
        
;(define 1fun (fun "x" "y" (mlet "z" (int 3) (add (var "y") (var "z")))))
;(define 2fun (fun "x" "y" (add (var "y") (int 1))))
;(define 3fun (fun "x" "y" (ifgreater (var "y") (int 5) (int 0) (add (var "y") (call (var "x") (add (var "y") (int 1)))))))
;(eval-exp (call 3fun (int 2)))

;; Problem 3

(define (ifaunit e1 e2 e3)
  (ifgreater (isaunit e1) (int 0) e2 e3)) ;; 这玩意才是正确的解决办法

(define (mlet* lstlst e2) ;; 递归形式的宏展开
  (if (null? lstlst)
      e2
      (let ([s (car (car lstlst))]
            [v (cdr (car lstlst))])
        (mlet s v (mlet* (cdr lstlst) e2)))))

;(define (ifeq e1 e2 e3 e4)
;  )
(define (ifeq e1 e2 e3 e4)
  (mlet* (list (cons "_x" e1) (cons "_y" e2))
         (ifgreater (var "_x") (var "_y") e4
                    (ifgreater (var "_y") (var "_x") e4 e3))))

;; Problem 4

(define mupl-map ;; 函数的名称是map，然后f是一个MUPL list
  (fun "map" "fn"
       (fun "mupl-map" "mlist"
            (ifaunit (var "mlist")
                     (aunit)
                     (apair (call (var "fn")
                                   (fst (var "mlist"))) 
                            (call (var "mupl-map") (snd (var "mlist"))))))))

(define mupl-mapAddN 
  (mlet "map" mupl-map
        (fun "mupl-mapAddN" "x" (call (var "map")
                                      (fun #f "y" (add (var "x") (var "y")))))))

;; Challenge Problem

(struct fun-challenge (nameopt formal body freevars) #:transparent) ;; a recursive(?) 1-argument function

;; We will test this function directly, so it must do
;; as described in the assignment
(define (compute-free-vars e) "CHANGE")

;; Do NOT share code with eval-under-env because that will make grading
;; more difficult, so copy most of your interpreter here and make minor changes
(define (eval-under-env-c e env) "CHANGE")

;; Do NOT change this
(define (eval-exp-c e)
  (eval-under-env-c (compute-free-vars e) null))

#+END_SRC
