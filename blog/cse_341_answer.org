#+TITLE:       Programming language 解题报告
#+AUTHOR:      Yihulee
#+EMAIL:       Yihulee@gmail.com
#+DATE:        2016-02-24 周三
#+URI:         /blog/%y/%m/%d/programming-language-解题报告
#+KEYWORDS:    Programming Language
#+TAGS:        wiki
#+LANGUAGE:    en
#+OPTIONS:     H:3 num:t toc:t \n:nil ::t |:t ^:nil -:nil f:t *:t <:t
#+DESCRIPTION: 解题报告

* homework1
** is_older
#+BEGIN_SRC sml
fun is_older (date1 : (int * int * int), date2 : (int * int * int)) =
  (*这个函数的要求是判断date1是否比date2更早，其实非常好判断，直接按照年月日判断即可*)
  if (#1 date1) <> (#1 date2) (* 年的值不同 *)
  then (#1 date1) < (#1 date2)
  else if (#2 date1) <> (#2 date2) (* 月的值不同 *)
  then (#2 date1) < (#2 date2)
  else if (#3 date1) <> (#3 date2) (* 天数不同 *)
  then (#3 date1) < (#3 date2)
  else false (* 到这里表示两个日期相同,返回false *)
#+END_SRC
** number_in_month
#+BEGIN_SRC sml
fun number_in_month (dl : (int * int * int) list, month : int) =
  (* 参数是一个 list of dates 和一个 month,要返回的结果是在指定的这个月里，这个dates中月份等于该month的一共有多少个 *)
  if null dl
  then 0
  else if (#2 (hd dl)) = month
  then 1 + number_in_month(tl dl, month)
  else number_in_month(tl dl, month)
#+END_SRC

** number_in_months
#+BEGIN_SRC sml
fun number_in_months(dl : (int * int * int) list, ml : int list) =
  if null ml
  then []
  else number_in_month(dl, hd ml)::number_in_months(dl, tl ml)
#+END_SRC

** dates_in_month
#+BEGIN_SRC sml
fun dates_in_month(dl : (int * int * int) list, m : int) =
  if null dl
  then []
  else if (#2 (hd dl)) = m
  then (hd dl)::dates_in_month(tl dl, m)
  else dates_in_month(tl dl, m)
#+END_SRC

** dates_in_months
#+BEGIN_SRC sml
fun dates_in_months(dl : (int * int * int) list, ml : int list) =
  if null ml
  then []
  else [dates_in_month(dl, hd ml)] @ dates_in_months(dl, tl ml)

#+END_SRC

** get_nth
#+BEGIN_SRC sml
fun get_nth (sl : string list , nth : int) =
  (* 题目里的说明是不用担心sl太短，这样的话，函数就可以变得很简洁了*)
  if nth = 1
  then hd sl
  else get_nth(tl sl, nth - 1)
#+END_SRC

** date_to_string
#+BEGIN_SRC sml
fun date_to_string (date : (int * int * int)) =
  let val ml = ["January", "February", "March",
	  "April", "May", "June", "July",
	  "August", "September", "October",
	  "November", "December"]
  in
     get_nth(ml, (#2 date)) ^ " " ^Int.toString((#3 date)) ^ ", " ^ Int.toString((#1 date))
  end
#+END_SRC

** number_before_reaching_sum
#+BEGIN_SRC sml
fun number_before_reaching_sum (sum : int, il : int list) =
  (* 这玩意挺爽的一点是，里面可以做辅助函数 *)
  let
      fun helper (il : int list, sum_of_n_items : int, n_item : int) = (* sum_of_n_items是前面的n项的和，n_item是第n项*)
	if sum_of_n_items >= sum
	then n_item
	else helper(tl il, sum_of_n_items + hd il, n_item + 1)
  in
      helper(il, 0, 0)
  end
#+END_SRC

** what_month
#+BEGIN_SRC sml
fun what_month (day : int) =
  (* 这是一个简化版的程序，忽略了闰年 *)
  let
      val day_of_each_month = [31, 28, 31, 30,
			       31, 30, 31, 31,
			       30, 31, 30, 31] (* 每个月的天数 *)
      fun count_days (rest_days : int, day_of_each_month : int list, nth : int) =
	if rest_days <=  hd day_of_each_month
	then nth
	else count_days(rest_days - hd day_of_each_month, tl day_of_each_month, nth + 1)
  in
      count_days(day, day_of_each_month, 1)
  end

#+END_SRC

** month_range
#+BEGIN_SRC sml
fun month_range (day1 : int, day2 : int) =
  if day1 > day2
  then []
  else if day1 = day2
  then [what_month(day2)]
  else what_month(day1)::month_range(day1 + 1, day2)
#+END_SRC

** oldest
#+BEGIN_SRC sml
fun oldest (dl : (int * int * int) list) =
  if null dl
  then NONE
  else let
      fun oldest_date(dl : (int * int * int) list) =
	if null (tl dl)
	then hd dl
	else let val dl_ans = oldest_date(tl dl)
	     in
		 if is_older(dl_ans, hd dl)
		 then hd dl
		 else dl_ans
	     end
  in
      SOME(oldest_date(dl))
  end

#+END_SRC

** number_in_months_challenge
#+BEGIN_SRC sml
fun number_in_months_challenge (dl : (int * int * int) list, ml : int list) =
  (* 我们要做的是，去除重复的月份即可,使用local function *)
  let
      fun reverse_list(il : int list) =
      (* 这个函数用于反转list *)
	let
	    fun iter (remained_list : int list, result : int list) =
	      if null remained_list
	      then result
	      else iter(tl remained_list, hd remained_list :: result)
	in
	    iter(il, [])
	end
	    
      fun filter_dup (il : int list, result : int list) =
	(* 关键的问题在于如何去除重复 *)
	if null il
	then result
	else if
	    let
		fun in_the_list (n : int , il : int list) = (* 这个函数主要用来判断n是否在il这个int list之中*)
		  if null il
		  then false
		  else if n = hd il
		  then true
		  else in_the_list(n, tl il) (* 这个函数的定义倒是没有什么错误 *)
	    in
		in_the_list(hd il, result) (* 判断 hd il 是否在result之中*)
	    end
	then filter_dup(tl il, result) (* 在result之中，则继续迭代*)
	else filter_dup(tl il, hd il::result) (* 不在result之中，则加入result*)
  in
      number_in_months(dl, reverse_list(filter_dup(ml, [])))
  end
#+END_SRC
** reasonable_date
#+BEGIN_SRC sml
(* 最后一个函数了 *)
fun reasonable_date (date : (int * int * int)) =
  if (#1 date) <= 0
  then false
  else if (# 2 date) > 12 orelse (#2 date) < 1
  then false
  else
      let
	  fun is_leap_year(year : int) =
	    (* 判断某年是否为闰年 *)
	    if year mod 400 = 0 orelse (year mod 4 = 0 andalso year mod 100 <> 0)
	    then true
	    else false

	  fun get_nth(il : int list, n : int) = (* 取list表单的第n项 *)
	     if n = 1
	     then hd il
	     else get_nth(tl il, n - 1)

	  val day_of_each_month_in_leap_year = [31, 29, 31, 30,
						31, 30, 31, 31,
						30, 31, 30, 31]

	  val day_of_each_month_in_ord_year = [31, 28, 31, 30,
						31, 30, 31, 31,
						30, 31, 30, 31]
      in
	  let
	      fun is_day_right(d : int, m : int, day_of_each_month : int list) =
		if d > 0 andalso d <= get_nth(day_of_each_month, m)
		then true
		else false
	  in
	      if is_leap_year((#1 date))
	      then is_day_right((#3 date), (#2 date), day_of_each_month_in_leap_year) (* 如果是闰年 *)
	      else is_day_right((#3 date), (#2 date), day_of_each_month_in_ord_year) (* 如果不是闰年 *)
	  end
	      
      end

#+END_SRC
* homework2
** all_except_iotion
#+BEGIN_SRC sml
fun same_string(s1 : string, s2 : string) =
    s1 = s2

(* 不允许使用函数null, hd, tl, isSome, valOf, or # *)
fun all_except_option (str, strl) =
  (* 我来分析一下匹配的结果，首先，如果strl为空，自然返回NONE
     然后，如果strl的首元素和str匹配，返回SOME，否则的话，继续递归 *)
  (* 这里有一个假设，那就是str至多在strl中出现一次 *)
  case strl of
      [] => NONE
    | x::xs' => if same_string(str, x)
		then SOME(xs') (* 去除了str后形成的新的SOME *)
		else
		    let val re = all_except_option(str, xs')
		    in
			case re of
			    NONE => NONE
			 | SOME px => SOME(x::px)
		    end

#+END_SRC

** get_substitutions1
#+BEGIN_SRC sml
fun get_substitutions1 (sll, s) =
(* 这个函数显然要用到前面定义的辅助函数 *)
  case sll of
      [] => []
    | x::xs' => let val re = all_except_option(s, x)
		in case re of
		       NONE => get_substitutions1(xs', s)
		     | SOME v => v @ get_substitutions1(xs', s)
		end
#+END_SRC

** get_substitutions2
#+BEGIN_SRC sml
fun get_substitutions2 (sll, s) =
(* 尾递归版本的替换 *)
  let fun sub(sll, acc) =
	case sll of
	    [] => acc
	  | x::xs' => let val re = all_except_option(s, x) (* 得到这个list的结果 *)
		      in case re of
			     NONE => sub(xs', acc) (* 继续往后面递归 *)
			   | SOME v => sub(xs', v @ acc) (* 累积一下，继续递归 *)
		      end
  in
      sub(sll, [])
  end
#+END_SRC
** similar_names
#+BEGIN_SRC sml
fun similar_names (sll, full_name) =
(* 其实也是很简单的一道题目 *)
  let
      val {first = x, middle = y, last = z} = full_name
      val ans = [full_name] (* 事先将full_name装入 *)
  in
      let
	  val temp =  get_substitutions2(sll, x) (* 这样可以得到一个替换的结果,用first name x 去替换 *)
	  fun sub (sl, ans) =
	    case sl of
		[] => ans
	      | h::t  =>  sub(t, {first = h, middle = y, last = z} :: ans)
									
      in
	  sub(temp, ans) (* 替换 *)
      end
  end
#+END_SRC
** card_color
#+BEGIN_SRC sml
datatype suit = Clubs | Diamonds | Hearts | Spades
datatype rank = Jack | Queen | King | Ace | Num of int 
type card = suit * rank

datatype color = Red | Black
datatype move = Discard of card | Draw 

exception IllegalMove

(* put your solutions for problem 2 here *)
fun card_color (c) =
  case c of
      (s, k) => k

#+END_SRC

** card_value
#+BEGIN_SRC sml
fun card_value (c, k) =
  case k of
      Ace => 11
    | Num i => i
    | _ => 10
#+END_SRC
** remove_card
#+BEGIN_SRC sml
fun remove_card	(cs, c, exn) =
  case cs of
      ac :: rc => if ac = c
		  then rc
		  else ac :: remove_card(rc, c, exn)
    | [] => raise exn
#+END_SRC
** all_same_color
#+BEGIN_SRC sml
fun all_same_color (cs) =
  case cs of
      (c1, v1) :: (c2, v2) :: rc => if c1 = c2
				    then all_same_color((c2, v2) :: rc)
				    else false
    | _  => true 
#+END_SRC
** sum_cards
#+BEGIN_SRC sml
fun sum_cards (cs) =
  (* 需要使用到尾递归 *)
  let
      fun helper_sum_cards(cards, acc) =
	case cards of
	    c :: rc => helper_sum_cards(rc, card_value(c) + acc)
	  | [] =>  acc
  in
      helper_sum_cards(cs, 0)
  end
#+END_SRC
** score
#+BEGIN_SRC sml
fun score (cs, goal) =
  (* 计算成绩 *)
  let val sum = sum_cards(cs)
  in
      let
	  val  reliminary_score =      
	      if sum > goal
	      then 3 * (sum - goal)
	      else goal - sum
      in
	  if all_same_color(cs) (* 如果牌是相同的颜色，那么成绩就是preliminary score除2 *)
	  then reliminary_score
	  else reliminary_score div 2
      end
  end
#+END_SRC

** officiate
#+BEGIN_SRC sml
fun officiate (card_list, move_list, goal) =
  let
      fun helper_officiate (card_list, herd_list, move_list, goal) =
	(* card_list是牌的列表，herd_list是现在手里有的牌的列表，而move_list表示每一步应该怎样走 *)
	case move_list of
	    [] => score(herd_list, goal) (* 移动列表中已经没有东西了，立即返回score *)
	  | Draw :: rest_moves => (* 这里的要求是，抓取一张牌 *) 
	    (case card_list of 
		 card :: rest_cards =>
		 let
		     val new_herd_list = card :: herd_list
		 in
		     if sum_cards(new_herd_list) > goal (* 抓牌后是的新的herd_list的分数sum超过了goal *)
		     then score(new_herd_list, goal)
		     else  helper_officiate(rest_cards, card :: herd_list, rest_moves, goal) 
		 end
	       | [] => score(herd_list, goal) (* 已经没有牌了，游戏结束，所以返回score *)
	    )
	 |  Discard card :: rest_moves =>  helper_officiate(card_list, remove_card(herd_list, card, IllegalMove), rest_moves, goal)
  in
      helper_officiate(card_list, [], move_list, goal)
  end
#+END_SRC
