<!DOCTYPE html>
<html lang="en-us">
  <head>
    <title>Programming language 解题报告 - Yihulee&#39;s world!</title>
    <meta charset="utf-8" />
    <meta name="author" content="Yihulee" />
    <meta name="description" content="解题报告" />
    <meta name="keywords" content="Programming Language" />
    <link rel="stylesheet" href="/media/css/main.css" type="text/css">
    <link rel="stylesheet" href="/media/css/prettify.css" type="text/css">
  </head>
  <body class="container">
    <div>
      <header class="masthead">
        <h1 class="masthead-title"><a href="/">Yihulee&#39;s world!</a></h1>
        <p>=========&gt;易燃又美味！</p>
        <ul>
          <li><a href="/blog/">Blog</a></li>
          <li><a href="/essay/">Essay</a></li>
          <li><a href="/tags/">Tags</a></li>
          <li><a href="/about/">About</a></li>
          <li><a href="https://github.com/Yihulee">GitHub</a></li>
          <li><a href="/rss.xml">RSS</a></li>
        </ul>
        <form method="get" id="searchform" action="http://www.google.com/search">
          <input type="text" class="field" name="q" id="s" placeholder="Search">
          <input type="hidden" name="as_sitesearch" value="Yihulee.github.io">
        </form>
      </header>
    </div>

<div>
<div class="post">
<h1>Programming language 解题报告</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgheadline14">1. homework1</a>
<ul>
<li><a href="#orgheadline1">1.1. is_older</a></li>
<li><a href="#orgheadline2">1.2. number_in_month</a></li>
<li><a href="#orgheadline3">1.3. number_in_months</a></li>
<li><a href="#orgheadline4">1.4. dates_in_month</a></li>
<li><a href="#orgheadline5">1.5. dates_in_months</a></li>
<li><a href="#orgheadline6">1.6. get_nth</a></li>
<li><a href="#orgheadline7">1.7. date_to_string</a></li>
<li><a href="#orgheadline8">1.8. number_before_reaching_sum</a></li>
<li><a href="#orgheadline9">1.9. what_month</a></li>
<li><a href="#orgheadline10">1.10. month_range</a></li>
<li><a href="#orgheadline11">1.11. oldest</a></li>
<li><a href="#orgheadline12">1.12. number_in_months_challenge</a></li>
<li><a href="#orgheadline13">1.13. reasonable_date</a></li>
</ul>
</li>
<li><a href="#orgheadline26">2. homework2</a>
<ul>
<li><a href="#orgheadline15">2.1. all_except_iotion</a></li>
<li><a href="#orgheadline16">2.2. get_substitutions1</a></li>
<li><a href="#orgheadline17">2.3. get_substitutions2</a></li>
<li><a href="#orgheadline18">2.4. similar_names</a></li>
<li><a href="#orgheadline19">2.5. card_color</a></li>
<li><a href="#orgheadline20">2.6. card_value</a></li>
<li><a href="#orgheadline21">2.7. remove_card</a></li>
<li><a href="#orgheadline22">2.8. all_same_color</a></li>
<li><a href="#orgheadline23">2.9. sum_cards</a></li>
<li><a href="#orgheadline24">2.10. score</a></li>
<li><a href="#orgheadline25">2.11. officiate</a></li>
</ul>
</li>
<li><a href="#orgheadline44">3. homework3</a>
<ul>
<li><a href="#orgheadline27">3.1. count_wildcards</a></li>
<li><a href="#orgheadline28">3.2. count_wildcards_e</a></li>
<li><a href="#orgheadline29">3.3. count_wild_and_variable_lengths</a></li>
<li><a href="#orgheadline30">3.4. count_some_var</a></li>
<li><a href="#orgheadline31">3.5. check_pat</a></li>
<li><a href="#orgheadline32">3.6. only_capitals</a></li>
<li><a href="#orgheadline33">3.7. longest_string1</a></li>
<li><a href="#orgheadline34">3.8. longest_string2</a></li>
<li><a href="#orgheadline35">3.9. longest_string3</a></li>
<li><a href="#orgheadline36">3.10. longest_string4</a></li>
<li><a href="#orgheadline37">3.11. longest_string_helper</a></li>
<li><a href="#orgheadline38">3.12. longest_capitalized</a></li>
<li><a href="#orgheadline39">3.13. rev_string</a></li>
<li><a href="#orgheadline40">3.14. first_answer</a></li>
<li><a href="#orgheadline41">3.15. all_answers</a></li>
<li><a href="#orgheadline42">3.16. match</a></li>
<li><a href="#orgheadline43">3.17. first_match</a></li>
</ul>
</li>
<li><a href="#orgheadline45">4. homework4</a></li>
<li><a href="#orgheadline46">5. homework5</a></li>
<li><a href="#orgheadline47">6. homework6</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline14" class="outline-2">
<h2 id="orgheadline14"><span class="section-number-2">1</span> homework1</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-orgheadline1" class="outline-3">
<h3 id="orgheadline1"><span class="section-number-3">1.1</span> is_older</h3>
<div class="outline-text-3" id="text-1-1">
<div class="org-src-container">

<pre class="src src-sml">fun is_older (date1 : (int * int * int), date2 : (int * int * int)) =
  (*这个函数的要求是判断date1是否比date2更早，其实非常好判断，直接按照年月日判断即可*)
  if (#1 date1) &lt;&gt; (#1 date2) (* 年的值不同 *)
  then (#1 date1) &lt; (#1 date2)
  else if (#2 date1) &lt;&gt; (#2 date2) (* 月的值不同 *)
  then (#2 date1) &lt; (#2 date2)
  else if (#3 date1) &lt;&gt; (#3 date2) (* 天数不同 *)
  then (#3 date1) &lt; (#3 date2)
  else false (* 到这里表示两个日期相同,返回false *)
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline2" class="outline-3">
<h3 id="orgheadline2"><span class="section-number-3">1.2</span> number_in_month</h3>
<div class="outline-text-3" id="text-1-2">
<div class="org-src-container">

<pre class="src src-sml">fun number_in_month (dl : (int * int * int) list, month : int) =
  (* 参数是一个 list of dates 和一个 month,要返回的结果是在指定的这个月里，这个dates中月份等于该month的一共有多少个 *)
  if null dl
  then 0
  else if (#2 (hd dl)) = month
  then 1 + number_in_month(tl dl, month)
  else number_in_month(tl dl, month)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline3" class="outline-3">
<h3 id="orgheadline3"><span class="section-number-3">1.3</span> number_in_months</h3>
<div class="outline-text-3" id="text-1-3">
<div class="org-src-container">

<pre class="src src-sml">fun number_in_months(dl : (int * int * int) list, ml : int list) =
  if null ml
  then []
  else number_in_month(dl, hd ml)::number_in_months(dl, tl ml)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline4" class="outline-3">
<h3 id="orgheadline4"><span class="section-number-3">1.4</span> dates_in_month</h3>
<div class="outline-text-3" id="text-1-4">
<div class="org-src-container">

<pre class="src src-sml">fun dates_in_month(dl : (int * int * int) list, m : int) =
  if null dl
  then []
  else if (#2 (hd dl)) = m
  then (hd dl)::dates_in_month(tl dl, m)
  else dates_in_month(tl dl, m)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline5" class="outline-3">
<h3 id="orgheadline5"><span class="section-number-3">1.5</span> dates_in_months</h3>
<div class="outline-text-3" id="text-1-5">
<div class="org-src-container">

<pre class="src src-sml">fun dates_in_months(dl : (int * int * int) list, ml : int list) =
  if null ml
  then []
  else [dates_in_month(dl, hd ml)] @ dates_in_months(dl, tl ml)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline6" class="outline-3">
<h3 id="orgheadline6"><span class="section-number-3">1.6</span> get_nth</h3>
<div class="outline-text-3" id="text-1-6">
<div class="org-src-container">

<pre class="src src-sml">fun get_nth (sl : string list , nth : int) =
  (* 题目里的说明是不用担心sl太短，这样的话，函数就可以变得很简洁了*)
  if nth = 1
  then hd sl
  else get_nth(tl sl, nth - 1)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline7" class="outline-3">
<h3 id="orgheadline7"><span class="section-number-3">1.7</span> date_to_string</h3>
<div class="outline-text-3" id="text-1-7">
<div class="org-src-container">

<pre class="src src-sml">fun date_to_string (date : (int * int * int)) =
  let val ml = ["January", "February", "March",
	  "April", "May", "June", "July",
	  "August", "September", "October",
	  "November", "December"]
  in
     get_nth(ml, (#2 date)) ^ " " ^Int.toString((#3 date)) ^ ", " ^ Int.toString((#1 date))
  end
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline8" class="outline-3">
<h3 id="orgheadline8"><span class="section-number-3">1.8</span> number_before_reaching_sum</h3>
<div class="outline-text-3" id="text-1-8">
<div class="org-src-container">

<pre class="src src-sml">fun number_before_reaching_sum (sum : int, il : int list) =
  (* 这玩意挺爽的一点是，里面可以做辅助函数 *)
  let
      fun helper (il : int list, sum_of_n_items : int, n_item : int) = (* sum_of_n_items是前面的n项的和，n_item是第n项*)
	if sum_of_n_items &gt;= sum
	then n_item
	else helper(tl il, sum_of_n_items + hd il, n_item + 1)
  in
      helper(il, 0, 0)
  end
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline9" class="outline-3">
<h3 id="orgheadline9"><span class="section-number-3">1.9</span> what_month</h3>
<div class="outline-text-3" id="text-1-9">
<div class="org-src-container">

<pre class="src src-sml">fun what_month (day : int) =
  (* 这是一个简化版的程序，忽略了闰年 *)
  let
      val day_of_each_month = [31, 28, 31, 30,
			       31, 30, 31, 31,
			       30, 31, 30, 31] (* 每个月的天数 *)
      fun count_days (rest_days : int, day_of_each_month : int list, nth : int) =
	if rest_days &lt;=  hd day_of_each_month
	then nth
	else count_days(rest_days - hd day_of_each_month, tl day_of_each_month, nth + 1)
  in
      count_days(day, day_of_each_month, 1)
  end
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline10" class="outline-3">
<h3 id="orgheadline10"><span class="section-number-3">1.10</span> month_range</h3>
<div class="outline-text-3" id="text-1-10">
<div class="org-src-container">

<pre class="src src-sml">fun month_range (day1 : int, day2 : int) =
  if day1 &gt; day2
  then []
  else if day1 = day2
  then [what_month(day2)]
  else what_month(day1)::month_range(day1 + 1, day2)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline11" class="outline-3">
<h3 id="orgheadline11"><span class="section-number-3">1.11</span> oldest</h3>
<div class="outline-text-3" id="text-1-11">
<div class="org-src-container">

<pre class="src src-sml">fun oldest (dl : (int * int * int) list) =
  if null dl
  then NONE
  else let
      fun oldest_date(dl : (int * int * int) list) =
	if null (tl dl)
	then hd dl
	else let val dl_ans = oldest_date(tl dl)
	     in
		 if is_older(dl_ans, hd dl)
		 then hd dl
		 else dl_ans
	     end
  in
      SOME(oldest_date(dl))
  end
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline12" class="outline-3">
<h3 id="orgheadline12"><span class="section-number-3">1.12</span> number_in_months_challenge</h3>
<div class="outline-text-3" id="text-1-12">
<div class="org-src-container">

<pre class="src src-sml">fun number_in_months_challenge (dl : (int * int * int) list, ml : int list) =
  (* 我们要做的是，去除重复的月份即可,使用local function *)
  let
      fun reverse_list(il : int list) =
      (* 这个函数用于反转list *)
	let
	    fun iter (remained_list : int list, result : int list) =
	      if null remained_list
	      then result
	      else iter(tl remained_list, hd remained_list :: result)
	in
	    iter(il, [])
	end

      fun filter_dup (il : int list, result : int list) =
	(* 关键的问题在于如何去除重复 *)
	if null il
	then result
	else if
	    let
		fun in_the_list (n : int , il : int list) = (* 这个函数主要用来判断n是否在il这个int list之中*)
		  if null il
		  then false
		  else if n = hd il
		  then true
		  else in_the_list(n, tl il) (* 这个函数的定义倒是没有什么错误 *)
	    in
		in_the_list(hd il, result) (* 判断 hd il 是否在result之中*)
	    end
	then filter_dup(tl il, result) (* 在result之中，则继续迭代*)
	else filter_dup(tl il, hd il::result) (* 不在result之中，则加入result*)
  in
      number_in_months(dl, reverse_list(filter_dup(ml, [])))
  end
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline13" class="outline-3">
<h3 id="orgheadline13"><span class="section-number-3">1.13</span> reasonable_date</h3>
<div class="outline-text-3" id="text-1-13">
<div class="org-src-container">

<pre class="src src-sml">(* 最后一个函数了 *)
fun reasonable_date (date : (int * int * int)) =
  if (#1 date) &lt;= 0
  then false
  else if (# 2 date) &gt; 12 orelse (#2 date) &lt; 1
  then false
  else
      let
	  fun is_leap_year(year : int) =
	    (* 判断某年是否为闰年 *)
	    if year mod 400 = 0 orelse (year mod 4 = 0 andalso year mod 100 &lt;&gt; 0)
	    then true
	    else false

	  fun get_nth(il : int list, n : int) = (* 取list表单的第n项 *)
	     if n = 1
	     then hd il
	     else get_nth(tl il, n - 1)

	  val day_of_each_month_in_leap_year = [31, 29, 31, 30,
						31, 30, 31, 31,
						30, 31, 30, 31]

	  val day_of_each_month_in_ord_year = [31, 28, 31, 30,
						31, 30, 31, 31,
						30, 31, 30, 31]
      in
	  let
	      fun is_day_right(d : int, m : int, day_of_each_month : int list) =
		if d &gt; 0 andalso d &lt;= get_nth(day_of_each_month, m)
		then true
		else false
	  in
	      if is_leap_year((#1 date))
	      then is_day_right((#3 date), (#2 date), day_of_each_month_in_leap_year) (* 如果是闰年 *)
	      else is_day_right((#3 date), (#2 date), day_of_each_month_in_ord_year) (* 如果不是闰年 *)
	  end

      end
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgheadline26" class="outline-2">
<h2 id="orgheadline26"><span class="section-number-2">2</span> homework2</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-orgheadline15" class="outline-3">
<h3 id="orgheadline15"><span class="section-number-3">2.1</span> all_except_iotion</h3>
<div class="outline-text-3" id="text-2-1">
<div class="org-src-container">

<pre class="src src-sml">fun same_string(s1 : string, s2 : string) =
    s1 = s2

(* 不允许使用函数null, hd, tl, isSome, valOf, or # *)
fun all_except_option (str, strl) =
  (* 我来分析一下匹配的结果，首先，如果strl为空，自然返回NONE
     然后，如果strl的首元素和str匹配，返回SOME，否则的话，继续递归 *)
  (* 这里有一个假设，那就是str至多在strl中出现一次 *)
  case strl of
      [] =&gt; NONE
    | x::xs' =&gt; if same_string(str, x)
		then SOME(xs') (* 去除了str后形成的新的SOME *)
		else
		    let val re = all_except_option(str, xs')
		    in
			case re of
			    NONE =&gt; NONE
			 | SOME px =&gt; SOME(x::px)
		    end
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline16" class="outline-3">
<h3 id="orgheadline16"><span class="section-number-3">2.2</span> get_substitutions1</h3>
<div class="outline-text-3" id="text-2-2">
<div class="org-src-container">

<pre class="src src-sml">fun get_substitutions1 (sll, s) =
(* 这个函数显然要用到前面定义的辅助函数 *)
  case sll of
      [] =&gt; []
    | x::xs' =&gt; let val re = all_except_option(s, x)
		in case re of
		       NONE =&gt; get_substitutions1(xs', s)
		     | SOME v =&gt; v @ get_substitutions1(xs', s)
		end
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline17" class="outline-3">
<h3 id="orgheadline17"><span class="section-number-3">2.3</span> get_substitutions2</h3>
<div class="outline-text-3" id="text-2-3">
<div class="org-src-container">

<pre class="src src-sml">fun get_substitutions2 (sll, s) =
(* 尾递归版本的替换 *)
  let fun sub(sll, acc) =
	case sll of
	    [] =&gt; acc
	  | x::xs' =&gt; let val re = all_except_option(s, x) (* 得到这个list的结果 *)
		      in case re of
			     NONE =&gt; sub(xs', acc) (* 继续往后面递归 *)
			   | SOME v =&gt; sub(xs', v @ acc) (* 累积一下，继续递归 *)
		      end
  in
      sub(sll, [])
  end
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline18" class="outline-3">
<h3 id="orgheadline18"><span class="section-number-3">2.4</span> similar_names</h3>
<div class="outline-text-3" id="text-2-4">
<div class="org-src-container">

<pre class="src src-sml">fun similar_names (sll, full_name) =
(* 其实也是很简单的一道题目 *)
  let
      val {first = x, middle = y, last = z} = full_name
      val ans = [full_name] (* 事先将full_name装入 *)
  in
      let
	  val temp =  get_substitutions2(sll, x) (* 这样可以得到一个替换的结果,用first name x 去替换 *)
	  fun sub (sl, ans) =
	    case sl of
		[] =&gt; ans
	      | h::t  =&gt;  sub(t, {first = h, middle = y, last = z} :: ans)

      in
	  sub(temp, ans) (* 替换 *)
      end
  end
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline19" class="outline-3">
<h3 id="orgheadline19"><span class="section-number-3">2.5</span> card_color</h3>
<div class="outline-text-3" id="text-2-5">
<div class="org-src-container">

<pre class="src src-sml">datatype suit = Clubs | Diamonds | Hearts | Spades
datatype rank = Jack | Queen | King | Ace | Num of int 
type card = suit * rank

datatype color = Red | Black
datatype move = Discard of card | Draw 

exception IllegalMove

(* put your solutions for problem 2 here *)
fun card_color (c) =
  case c of
      (s, k) =&gt; k
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline20" class="outline-3">
<h3 id="orgheadline20"><span class="section-number-3">2.6</span> card_value</h3>
<div class="outline-text-3" id="text-2-6">
<div class="org-src-container">

<pre class="src src-sml">fun card_value (c, k) =
  case k of
      Ace =&gt; 11
    | Num i =&gt; i
    | _ =&gt; 10
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline21" class="outline-3">
<h3 id="orgheadline21"><span class="section-number-3">2.7</span> remove_card</h3>
<div class="outline-text-3" id="text-2-7">
<div class="org-src-container">

<pre class="src src-sml">fun remove_card (cs, c, exn) =
  case cs of
      ac :: rc =&gt; if ac = c
		  then rc
		  else ac :: remove_card(rc, c, exn)
    | [] =&gt; raise exn
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline22" class="outline-3">
<h3 id="orgheadline22"><span class="section-number-3">2.8</span> all_same_color</h3>
<div class="outline-text-3" id="text-2-8">
<div class="org-src-container">

<pre class="src src-sml">fun all_same_color (cs) =
  case cs of
      (c1, v1) :: (c2, v2) :: rc =&gt; if c1 = c2
				    then all_same_color((c2, v2) :: rc)
				    else false
    | _  =&gt; true
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline23" class="outline-3">
<h3 id="orgheadline23"><span class="section-number-3">2.9</span> sum_cards</h3>
<div class="outline-text-3" id="text-2-9">
<div class="org-src-container">

<pre class="src src-sml">fun sum_cards (cs) =
  (* 需要使用到尾递归 *)
  let
      fun helper_sum_cards(cards, acc) =
	case cards of
	    c :: rc =&gt; helper_sum_cards(rc, card_value(c) + acc)
	  | [] =&gt;  acc
  in
      helper_sum_cards(cs, 0)
  end
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline24" class="outline-3">
<h3 id="orgheadline24"><span class="section-number-3">2.10</span> score</h3>
<div class="outline-text-3" id="text-2-10">
<div class="org-src-container">

<pre class="src src-sml">fun score (cs, goal) =
  (* 计算成绩 *)
  let val sum = sum_cards(cs)
  in
      let
	  val  reliminary_score =      
	      if sum &gt; goal
	      then 3 * (sum - goal)
	      else goal - sum
      in
	  if all_same_color(cs) (* 如果牌是相同的颜色，那么成绩就是preliminary score除2 *)
	  then reliminary_score
	  else reliminary_score div 2
      end
  end
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline25" class="outline-3">
<h3 id="orgheadline25"><span class="section-number-3">2.11</span> officiate</h3>
<div class="outline-text-3" id="text-2-11">
<div class="org-src-container">

<pre class="src src-sml">fun officiate (card_list, move_list, goal) =
  let
      fun helper_officiate (card_list, herd_list, move_list, goal) =
	(* card_list是牌的列表，herd_list是现在手里有的牌的列表，而move_list表示每一步应该怎样走 *)
	case move_list of
	    [] =&gt; score(herd_list, goal) (* 移动列表中已经没有东西了，立即返回score *)
	  | Draw :: rest_moves =&gt; (* 这里的要求是，抓取一张牌 *) 
	    (case card_list of 
		 card :: rest_cards =&gt;
		 let
		     val new_herd_list = card :: herd_list
		 in
		     if sum_cards(new_herd_list) &gt; goal (* 抓牌后是的新的herd_list的分数sum超过了goal *)
		     then score(new_herd_list, goal)
		     else  helper_officiate(rest_cards, card :: herd_list, rest_moves, goal) 
		 end
	       | [] =&gt; score(herd_list, goal) (* 已经没有牌了，游戏结束，所以返回score *)
	    )
	 |  Discard card :: rest_moves =&gt;  helper_officiate(card_list, remove_card(herd_list, card, IllegalMove), rest_moves, goal)
  in
      helper_officiate(card_list, [], move_list, goal)
  end
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgheadline44" class="outline-2">
<h2 id="orgheadline44"><span class="section-number-2">3</span> homework3</h2>
<div class="outline-text-2" id="text-3">
<p>
  这次的东西确实有一点难度!
</p>
<div class="org-src-container">

<pre class="src src-sml">(* Dan Grossman, CSE341 Spring 2013, HW3 Provided Code *)
exception NoAnswer

datatype pattern = Wildcard
		 | Variable of string
		 | UnitP
		 | ConstP of int
		 | TupleP of pattern list
		 | ConstructorP of string * pattern

datatype valu = Const of int
	      | Unit
	      | Tuple of valu list
	      | Constructor of string * valu

fun g f1 f2 p =
    let 
	val r = g f1 f2 (* partial function *)
    in
	case p of (* p的类型是pattern *)
	    Wildcard          =&gt; f1 ()
	  | Variable x        =&gt; f2 x
	  | TupleP ps         =&gt; List.foldl (fn (p,i) =&gt; (r p) + i) 0 ps (* ps是一个list，r是一个函数，使用一个参数，返回int *)
	  | ConstructorP(_,p) =&gt; r p (* 只是要干什么呀 *)
	  | _                 =&gt; 0
    end

(* 题目要求是使用g来count_wildcards *)
</pre>
</div>
</div>

<div id="outline-container-orgheadline27" class="outline-3">
<h3 id="orgheadline27"><span class="section-number-3">3.1</span> count_wildcards</h3>
<div class="outline-text-3" id="text-3-1">
<div class="org-src-container">

<pre class="src src-sml">fun count_wildcards p =
  case p of
      ConstructorP (_, np) =&gt; count_wildcards np (* np也是一个pattern *)
    | Wildcard =&gt; 1
    | TupleP plist =&gt; (case plist of
			   x::(y::xs') =&gt; count_wildcards x + count_wildcards (TupleP (y::xs'))
			 | x::[] =&gt; count_wildcards x)
    | _ =&gt; 0
(*
    | ConstP _ =&gt; 0
    | UnitP =&gt; 0
    | Variable _ =&gt; 0 
*)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline28" class="outline-3">
<h3 id="orgheadline28"><span class="section-number-3">3.2</span> count_wildcards_e</h3>
<div class="outline-text-3" id="text-3-2">
<div class="org-src-container">

<pre class="src src-sml">fun count_wildcards_e p =
  g (fn x =&gt; 1) (fn x =&gt; 0) p
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline29" class="outline-3">
<h3 id="orgheadline29"><span class="section-number-3">3.3</span> count_wild_and_variable_lengths</h3>
<div class="outline-text-3" id="text-3-3">
<div class="org-src-container">

<pre class="src src-sml">fun count_wild_and_variable_lengths p =
  g (fn x =&gt; 1) (fn x =&gt; String.size x) p
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline30" class="outline-3">
<h3 id="orgheadline30"><span class="section-number-3">3.4</span> count_some_var</h3>
<div class="outline-text-3" id="text-3-4">
<div class="org-src-container">

<pre class="src src-sml">fun count_some_var s p =
  g (fn x =&gt; 0) (fn x =&gt; if x = s then 1 else 0) p
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline31" class="outline-3">
<h3 id="orgheadline31"><span class="section-number-3">3.5</span> check_pat</h3>
<div class="outline-text-3" id="text-3-5">
<div class="org-src-container">

<pre class="src src-sml">fun check_pat p =
  let
      fun collect_string p =
	case p of
	    Variable s =&gt; [s]
	  | TupleP ps  =&gt; List.foldl (fn (p, i) =&gt; i @ (collect_string p)) [] ps
	  | _ =&gt; []
      fun is_dup sl =
	case sl of
	    [] =&gt; false
	  | x::xs' =&gt; (List.exists (fn s =&gt; if x = s then true else false) xs') orelse is_dup xs' 
  in
     is_dup((collect_string p))
  end
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline32" class="outline-3">
<h3 id="orgheadline32"><span class="section-number-3">3.6</span> only_capitals</h3>
<div class="outline-text-3" id="text-3-6">
<div class="org-src-container">

<pre class="src src-sml">fun only_capitals (sl) =
  List.filter (fn x =&gt; Char.isUpper (String.sub(x, 0)))  sl
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline33" class="outline-3">
<h3 id="orgheadline33"><span class="section-number-3">3.7</span> longest_string1</h3>
<div class="outline-text-3" id="text-3-7">
<div class="org-src-container">

<pre class="src src-sml">(* foldl函数从左边干到右边，foldr函数从右边干到左边 *)
fun longest_string1 sl =
  foldl (fn (x, y) =&gt; if String.size x  &gt; String.size y then x else y) "" sl
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline34" class="outline-3">
<h3 id="orgheadline34"><span class="section-number-3">3.8</span> longest_string2</h3>
<div class="outline-text-3" id="text-3-8">
<div class="org-src-container">

<pre class="src src-sml">fun longest_string2 sl =
  foldl (fn (x, y) =&gt; if String.size x &gt;= String.size y then x  else y) "" sl
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline35" class="outline-3">
<h3 id="orgheadline35"><span class="section-number-3">3.9</span> longest_string3</h3>
<div class="outline-text-3" id="text-3-9">
<div class="org-src-container">

<pre class="src src-sml">val longest_string3 = foldl (fn (x, y) =&gt; if String.size x  &gt; String.size y then x else y) ""
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline36" class="outline-3">
<h3 id="orgheadline36"><span class="section-number-3">3.10</span> longest_string4</h3>
<div class="outline-text-3" id="text-3-10">
<div class="org-src-container">

<pre class="src src-sml">val longest_string4 = foldl (fn (x, y) =&gt; if String.size x &gt;= String.size y then x else y) ""
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline37" class="outline-3">
<h3 id="orgheadline37"><span class="section-number-3">3.11</span> longest_string_helper</h3>
<div class="outline-text-3" id="text-3-11">
<div class="org-src-container">

<pre class="src src-sml">fun longest_string_helper f sl = f sl
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline38" class="outline-3">
<h3 id="orgheadline38"><span class="section-number-3">3.12</span> longest_capitalized</h3>
<div class="outline-text-3" id="text-3-12">
<div class="org-src-container">

<pre class="src src-sml">val longest_capitalized = (longest_string1 o only_capitals)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline39" class="outline-3">
<h3 id="orgheadline39"><span class="section-number-3">3.13</span> rev_string</h3>
<div class="outline-text-3" id="text-3-13">
<div class="org-src-container">

<pre class="src src-sml">val rev_string  = implode o rev o explode
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline40" class="outline-3">
<h3 id="orgheadline40"><span class="section-number-3">3.14</span> first_answer</h3>
<div class="outline-text-3" id="text-3-14">
<div class="org-src-container">

<pre class="src src-sml">fun first_answer f l =
  (* f作用在list之上，然后直到list返回一个SOME v*)
  case l of
      [] =&gt; raise NoAnswer
    | h::t =&gt; case f(h) of
		  SOME v =&gt; v
		| _ =&gt; first_answer f t
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline41" class="outline-3">
<h3 id="orgheadline41"><span class="section-number-3">3.15</span> all_answers</h3>
<div class="outline-text-3" id="text-3-15">
<div class="org-src-container">

<pre class="src src-sml">(* list option和option list很值得注意 *)
(* ('a -&gt; 'b list option) -&gt; 'a list -&gt; 'b list option *)
fun all_answers f l =
  (* 函数存在一些问题啊!l中的某个元素被f作用之后产生NONE，整个结果就是NONE，感觉不是很好递归的样子 *)
  case l of
      [] =&gt; SOME [] (*返回一个list option *)
    | h::t =&gt; case f(h) of
		  NONE =&gt; NONE
		| SOME r =&gt;
		  let
		     val re = (all_answers f t) (* 需要说明一下，re是一个list option,也就是说，如果re为SOME v，那么v是一个list*)
		  in
		      case re of
			  NONE =&gt; NONE
			| SOME v =&gt; SOME(r @ v) 
		  end
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline42" class="outline-3">
<h3 id="orgheadline42"><span class="section-number-3">3.16</span> match</h3>
<div class="outline-text-3" id="text-3-16">
<div class="org-src-container">

<pre class="src src-sml">fun match v_p =
   case v_p of
       (_ ,Wildcard) =&gt; SOME [] (* Wildcard 匹配一切 *)
     | (v, Variable s) =&gt; SOME [(s, v)] (*Variable s匹配任何的valu v*)
     | (Unit, UnitP) =&gt; SOME []
     | (Const v1, ConstP v2) =&gt; if v1 = v2 then SOME [] else NONE
     | ((Constructor (vs, vv)), (ConstructorP (ps, pp))) =&gt; if vs &lt;&gt; ps then NONE else match (vv, pp)
     | (Tuple v, TupleP p) =&gt; (all_answers match (ListPair.zip (v, p))) 
     | _ =&gt; NONE  (* 其余的都不匹配 *)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline43" class="outline-3">
<h3 id="orgheadline43"><span class="section-number-3">3.17</span> first_match</h3>
<div class="outline-text-3" id="text-3-17">
<div class="org-src-container">

<pre class="src src-sml">fun first_match v pl =
  SOME(first_answer (fn x =&gt; match (v, x)) pl) handle NoAnswer =&gt; NONE
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline45" class="outline-2">
<h2 id="orgheadline45"><span class="section-number-2">4</span> homework4</h2>
<div class="outline-text-2" id="text-4">
<div class="org-src-container">

<pre class="src src-scheme">#lang racket

(provide (all-defined-out)) ;; so we can put tests in a second file

;; put your code below

(define (sequence low high stride)
  (if (&gt; low high)
      null
      (cons low (sequence (+ low stride) high stride))))

(define (string-append-map xs suffix)
  (map (lambda (x) (string-append x suffix)) xs))

(define (list-nth-mod xs n)
  (let ([i (remainder n (length xs))])
    (cond [(&lt; n 0) (error "list-nth-mod: negative number")]
	  [(null? xs) (error "list-nth-mod: empty list")]
	  [else (begin (car (list-tail xs i)))])))

(define ones (lambda () (cons 1 ones)))
(define nat (letrec ([f (lambda (x) (cons x (lambda () (f (+ x 1)))))])
	      (lambda () (f 1))))

(define (stream-for-n-steps s n)
  (if (= n 0)
      null
      (cons (car (s)) (stream-for-n-steps (cdr (s))(- n 1)))))

(define funny-number-stream (letrec ([f (lambda (x)
					  (if (= (remainder x 5) 0)
					      (cons (- 0 x)
						    (lambda () (f (+ x 1))))
					      (cons x
						    (lambda () (f (+ x 1))))))])
			      (lambda () (f 1))))

(define dan-then-dog (letrec ([f (lambda (x)
				 (if (= (remainder x 2) 0)
				     (cons "dan.jpg"
					   (lambda () (f (+ x 1))))
				     (cons "dog.jpg"
					   (lambda () (f (+ x 1))))))])
		       (lambda () (f 0))))
(define (stream-add-zero s)
      (lambda () (cons (cons 0 (car (s))) (stream-add-zero (cdr (s))))))

;; 有了前面的玩意，后面就变得非常简单了
(define (cycle-lists xs ys)
  (letrec ([xl (length xs)] ;得到两个序列的长度
	   [yl (length ys)]
	   [f (lambda (ax ay) ;; 我们至少需要两个累积量，非常有趣的东西
		(cons (cons (list-nth-mod xs ax) (list-nth-mod ys ay))
		      (lambda () (f (remainder (+ 1 ax) xl) (remainder (+ 1 ay) yl)))))])
    (lambda () (f 0 0))))

(define (vector-assoc v vev)
  (letrec ([len (vector-length vev)]
	   [f (lambda (a)
		(if (= (- 1 len) a)
		    #f
		    (letrec ([vv (vector-ref vev a)])
		      (if (and (pair? vv) (equal? (car vv) v))
			      vv
			      (f (+ a 1))))))])
    (f 0)))


(define (cached-assoc xs n)
  (letrec
      ([cached-vector (make-vector n #f)]
       [index 0]
       [f (lambda (av ac) ;; 寻找某一个value,在vector之中
	    (cond
	      [(= ac n) #f]
	      [(letrec ([element-in-vector (vector-ref cached-vector ac)])
		 (and (pair? element-in-vector) (= (car element-in-vector) av) element-in-vector))]
	      [else (f av (+ ac 1))]))])
  (lambda (v)
    (letrec ([value-in-vector (f v 0)])
      (cond [(not value-in-vector)
	     (letrec ([value-in-list (assoc v xs)])
	       (begin (vector-set! cached-vector index value-in-list)
	       (set! index (remainder (+ 1 index) n)) value-in-list))] ;; 没有在vector中找到这个值
	    [else value-in-vector])))))
;; 定义一个宏 macro
(define-syntax  while-less
  (syntax-rules (do)
		[(while-less e1 do e2)
		 (letrec ([v1 e1]
		       [loop (lambda ()
				 (if (&gt; e2 (- v1 1))
				     #t
				     (loop)))])
		   (loop))]))
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline46" class="outline-2">
<h2 id="orgheadline46"><span class="section-number-2">5</span> homework5</h2>
<div class="outline-text-2" id="text-5">
<div class="org-src-container">

<pre class="src src-scheme">;; Programming Languages, Homework 5

#lang racket
(provide (all-defined-out)) ;; so we can put tests in a second file

;; definition of structures for MUPL programs - Do NOT change
(struct var  (string) #:transparent)  ;; a variable, e.g., (var "foo")
(struct int  (num)    #:transparent)  ;; a constant number, e.g., (int 17)
(struct add  (e1 e2)  #:transparent)  ;; add two expressions
(struct ifgreater (e1 e2 e3 e4)    #:transparent) ;; if e1 &gt; e2 then e3 else e4
(struct fun  (nameopt formal body) #:transparent) ;; a recursive(?) 1-argument function
(struct call (funexp actual)       #:transparent) ;; function call
(struct mlet (var e body) #:transparent) ;; a local binding (let var = e in body) 
(struct apair (e1 e2)     #:transparent) ;; make a new pair
(struct fst  (e)    #:transparent) ;; get first part of a pair
(struct snd  (e)    #:transparent) ;; get second part of a pair
(struct aunit ()    #:transparent) ;; unit value -- good for ending a list
(struct isaunit (e) #:transparent) ;; evaluate to 1 if e is unit else 0

;; a closure is not in "source" programs; it is what functions evaluate to
(struct closure (env fun) #:transparent) 

;; Problem 1

;; CHANGE (put your solutions here)
;; 这种题目果然只是用来热身的呀！
(define (racketlist-&gt;mupllist rl)
  (if (null? rl) (aunit)
      (apair (car rl) (racketlist-&gt;mupllist (cdr rl)))))

(define (mupllist-&gt;racketlist ml)
  (if (aunit? ml) null
      (cons (apair-e1 ml) (mupllist-&gt;racketlist (apair-e2 ml)))))
;; Problem 2

;; Implementing the MUPL Language

;; lookup a variable in an environment
;; Do NOT change this function
(define (envlookup env str) ;; 在环境env中寻找某个变量
  (cond [(null? env) (error "unbound variable during evaluation" str)]
	[(equal? (car (car env)) str) (cdr (car env))] ;; 如果值相同，就返回env里面的东西
	[#t (envlookup (cdr env) str)]))

;; Do NOT change the two cases given to you.  
;; DO add more cases for other kinds of MUPL expressions.
;; We will test eval-under-env by calling it directly even though
;; "in real life" it would be a helper function of eval-exp.
(define (eval-under-env e env)
  (cond [(var? e) ;; 如果e是变量
	 (envlookup env (var-string e))] ;; 在env中寻找对应的值
	[(add? e) ;; 如果e是加法表达式
	 (let ([v1 (eval-under-env (add-e1 e) env)]
	       [v2 (eval-under-env (add-e2 e) env)])
	   (if (and (int? v1)
		    (int? v2))
	       (int (+ (int-num v1) 
		       (int-num v2)))
	       (begin (print v1) (print v2)(
	       (error "MUPL addition applied to non-number")))))]
	;; CHANGE add more cases here
	[(fst? e) ;; 这里的要求是e的计算结果是apair
	 (let ([v (eval-under-env (fst-e e) env)])
	   (if (apair? v)
	       (apair-e1 v)
	       (error "e is not apair")))]
	[(snd? e) ;; 计算snd
	 (let ([v (eval-under-env (snd-e e) env)])
	   (if (apair? v)
	       (apair-e2 v)
	       (error "e is not apair")))]
	[(ifgreater? e) ;; 现在要解释ifgreater表达式了
	 (let ([v1 (eval-under-env (ifgreater-e1 e) env)]
	       [v2 (eval-under-env (ifgreater-e2 e) env)])
	   (if (and (int? v1) (int? v2))
	       (if (&gt; (int-num v1) (int-num v2))
		   (eval-under-env (ifgreater-e3 e) env)
		   (eval-under-env (ifgreater-e4 e) env))
	       (error "ifgreater expression needs two number")))]

	[(int? e) ;; 现在要处理整数
	 (let ([v (int-num e)])
	   (if (number? v)
	       e
	       (error "int expression encounter a thing that is not a number!")))]

	[(apair? e) ;; 处理apair表达式
	 (let ([v1 (eval-under-env (apair-e1 e) env)]
	       [v2 (eval-under-env (apair-e2 e) env)])
	   (apair v1 v2))]

	[(fun? e) ;; 现在处理函数，要求可以实现递归哦，是在是太他妈神奇了!
	 (let ([fun-name (fun-nameopt e)])
	   (if fun-name
	       (closure (append (list (cons fun-name e)) env) e)
	       (closure env e)))]

	[(mlet? e) ;; 处理mlet表达式
	 (letrec ([s (mlet-var e)] ;; 获得变量名
		  [v (eval-under-env (mlet-e e) env)]) ;; 获得值
	   (eval-under-env (mlet-body e) (append (list (cons s v)) env)))]

	[(call? e) ;; 这个东西是最重要的啦，我要实现闭包啦。
	 (letrec ([v1 (eval-under-env (call-funexp e) env)]
		  [v2 (eval-under-env (call-actual e) env)])
	   (if (closure? v1) ;; 要求v1是一个闭包
	       (letrec ([fn (closure-fun v1)] ;; 函数本体
			[fe (closure-env v1)]) ;; 原来的环境
		 (eval-under-env (fun-body fn)
				 (append (list (cons (fun-formal fn) v2))
					 fe)))
	       (if (fun? v1)
		   (eval-under-env (call v1 v2) env)
		   (error "She is not a closure!"))))]
	[(isaunit? e) ;; 现在开始处理isaunit表达式
	 (if (aunit? (eval-under-env (isaunit-e e) env)) (int 1) (int 0))]
	[(aunit? e) e]

	[#t (error (format "bad MUPL expression: ~v" e))]))

;; Do NOT change
(define (eval-exp e)
  (eval-under-env e null))

;(define 1fun (fun "x" "y" (mlet "z" (int 3) (add (var "y") (var "z")))))
;(define 2fun (fun "x" "y" (add (var "y") (int 1))))
;(define 3fun (fun "x" "y" (ifgreater (var "y") (int 5) (int 0) (add (var "y") (call (var "x") (add (var "y") (int 1)))))))
;(eval-exp (call 3fun (int 2)))

;; Problem 3

(define (ifaunit e1 e2 e3)
  (ifgreater (isaunit e1) (int 0) e2 e3)) ;; 这玩意才是正确的解决办法

(define (mlet* lstlst e2) ;; 递归形式的宏展开
  (if (null? lstlst)
      e2
      (let ([s (car (car lstlst))]
	    [v (cdr (car lstlst))])
	(mlet s v (mlet* (cdr lstlst) e2)))))

;(define (ifeq e1 e2 e3 e4)
;  )
(define (ifeq e1 e2 e3 e4)
  (mlet* (list (cons "_x" e1) (cons "_y" e2))
	 (ifgreater (var "_x") (var "_y") e4
		    (ifgreater (var "_y") (var "_x") e4 e3))))

;; Problem 4

(define mupl-map ;; 函数的名称是map，然后f是一个MUPL list
  (fun "map" "fn"
       (fun "mupl-map" "mlist"
	    (ifaunit (var "mlist")
		     (aunit)
		     (apair (call (var "fn")
				   (fst (var "mlist"))) 
			    (call (var "mupl-map") (snd (var "mlist"))))))))

(define mupl-mapAddN 
  (mlet "map" mupl-map
	(fun "mupl-mapAddN" "x" (call (var "map")
				      (fun #f "y" (add (var "x") (var "y")))))))

;; Challenge Problem

(struct fun-challenge (nameopt formal body freevars) #:transparent) ;; a recursive(?) 1-argument function

;; We will test this function directly, so it must do
;; as described in the assignment
(define (compute-free-vars e) "CHANGE")

;; Do NOT share code with eval-under-env because that will make grading
;; more difficult, so copy most of your interpreter here and make minor changes
(define (eval-under-env-c e env) "CHANGE")

;; Do NOT change this
(define (eval-exp-c e)
  (eval-under-env-c (compute-free-vars e) null))
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline47" class="outline-2">
<h2 id="orgheadline47"><span class="section-number-2">6</span> homework6</h2>
<div class="outline-text-2" id="text-6">
<p>
这玩意比较麻烦！
</p>
<div class="org-src-container">

<pre class="src src-ruby"># University of Washington, Programming Languages, Homework 6, hw6runner.rb

# This is the only file you turn in, so do not modify the other files as
# part of your solution.

class MyPiece &lt; Piece
  # The constant All_My_Pieces should be declared here
  # class array holding all the pieces and their rotations
  # array，其中包含了所有的pieces和他们的旋转方式
  All_My_Pieces = Piece::All_Pieces.concat(
  [
    rotations([[0, 0], [1, 0], [0, 1], [1, 1], [-1, 0]]),
   [[[-1, 0], [-2, 0], [0, 0], [1, 0], [2, 0]],
     [[0, -1], [0, -2], [0, 0], [0, 1], [0, 2]]],
     rotations([[0, 0], [0, 1], [1, 0]])
  ])
  Cheat_Piece = [[[0, 0]]]

  # your enhancements here
  def self.next_piece (board) # 这个貌似是静态方法
	# puts "大家好，天气真晴朗啊！"
    Piece.new(All_My_Pieces.sample, board) # 随机挑选一个图形来做
  end

  def self.cheat_piece(board)
    MyPiece.new(Cheat_piece, board)
    # 开启欺骗模式
  end
end

class MyBoard &lt; Board
  # your enhancements here
  def initialize (game) # 初始化游戏，是吧！
   super # 所谓的super，就是将父类的代码放在前面，这个东西和C++里面有所不同啊！
   @current_block = MyPiece.next_piece(self) # piece 就是所谓的块结构
    @cheat_cost = 100
    @cheat_queued = false
  end

  # gets the next piece
  def next_piece # 我现在才发现，原来board也有next_piece方法，非常棒的东西啊！
    @current_block = MyPiece.next_piece(self) # 下一个块，是吧！
    @current_pos = nil
    if @cheat_queued
      @current_block = MyPiece.cheat_piece(self)
      @cheat_queued = false
    end
  end

  def store_current
	locations = @current_block.current_rotation
	displacement = @current_block.position
	(0..(locations.size-1)).each{
		|index| 
		current = locations[index];
		@grid[current[1]+displacement[1]][current[0]+displacement[0]] = 
		@current_pos[index]
	}
	remove_filled
	@delay = [@delay - 2, 80].max
  end

  def rotate_180_degree
    if !game_over? and @game.is_running?
      @current_block.move(0, 0, 2) # 旋转180°
    end
    draw # draw 这玩意，你理解为重绘吧！
  end

  def new_game
    super
    @cheat_queued = false
  end

  def cheat
    return if @cheat_queued || @score &lt; @cheat_cost
    @cheat_queued = true
    @score -= @cheat_cost
  end
end

class MyTetris &lt; Tetris

  def set_board
    @canvas = TetrisCanvas.new
    @board = MyBoard.new(self)
    @canvas.place(@board.block_size * @board.num_rows + 3,
		  @board.block_size * @board.num_columns + 6, 24, 80)
    @board.draw
  end

  def key_bindings  # 这里终于看到键盘的绑定了！
   super
   @root.bind('u', proc{@board.rotate_180_degree})
    @root.bind('c', proc{@board.cheat})
  end
end
</pre>
</div>
</div>
</div>

</div>
</div>
    <div>
      <div class="post-meta">
        <span title="post date" class="post-info">2016-02-24</span>
        <span title="last modification date" class="post-info">2016-03-05</span>
        <span title="tags" class="post-info"><a href="/tags/wiki/">wiki</a></span>
        <span title="author" class="post-info">Yihulee</span>
      </div>
      <section>
        <h1>Comments</h1>
        <div class="ds-thread"></div>
        <script type="text/javascript">
          var duoshuoQuery = {short_name:'lishuhuakai'};
          (function() {
          var ds = document.createElement('script');
          ds.type = 'text/javascript';ds.async = true;
          ds.src = 'http://static.duoshuo.com/embed.js';
          ds.charset = 'UTF-8';
          (document.getElementsByTagName('head')[0]
          || document.getElementsByTagName('body')[0]).appendChild(ds);
          })();
        </script>
      </section>
      <script src="http://code.jquery.com/jquery-latest.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.js"></script>
      <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      <script src="/media/js/main.js"></script>
      <div class="footer">
        <p>Generated by <a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.x (<a href="http://orgmode.org">Org mode</a> 8.x)</p>
        <p>
          Copyright &copy; 2012 - <span id="footerYear"></span> <a href="mailto:Yihulee &lt;at&gt; gmail &lt;dot&gt; com">Yihulee</a>
          &nbsp;&nbsp;-&nbsp;&nbsp;
          Powered by <a href="https://github.com/kelvinh/org-page" target="_blank">org-page</a>
          <script type="text/javascript">document.getElementById("footerYear").innerHTML = (new Date()).getFullYear();</script>
        </p>
      </div>
    </div>

  </body>
</html>
